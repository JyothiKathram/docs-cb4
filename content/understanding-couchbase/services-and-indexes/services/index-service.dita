<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Concept//EN" "topic.dtd">
<topic id="index_service">
 
 <title>Index Service</title>
 
 <shortdesc>
  The <i>Index Service</i> supports the creation of <i>primary</i> and <i>secondary</i> indexes
  on items stored within Couchbase Server. The indexes are used by the <i>Query Service</i>, which
  itself supports queries made by the <i>N1QL</i> query language. Use of the Index and Query services
  depends on the presence of at least one instance of the <i>Data Service</i> on the Couchbase
  Server-cluster.
 </shortdesc>
 
 <body>
  
  <section>
   
   <title>
    Index Service Architecture
   </title>
  
    <p>
     Components essential for the <i>Index Service</i> reside on not only on
     each node to which the Index Service is assigned, but also to each node to which the
     <i>Data Service</i> is assigned, as shown by the following illustration:
    </p>
   
   <p>
    <image href="./images/indexServiceArchitecture.png" id="index_service_architecture" align="left" width="700"/>
   </p>
   
   <p>
    The illustration depicts the following:
   </p>
   
   <p>
   </p>
   
   <ul>
    <li>
     <b>Data Service</b>: Uses the DCP protocol to stream data-mutations 
     to the <b>Projector and Router</b>
     process, which runs as part of the Index Service, on each Data Service node.
     <p>
      
     </p>
    </li>
    
    <li>
     <b>Projector and Router</b>: Provides data to the Index Service, according to the 
     index-definitions provided by the Index Service Supervisor.
     
     <p>
      When the <b>Projector and Router</b> starts running on the Data Service-node,
      the Data Service streams to the <b>Projector and Router</b> copies of all 
      mutations that occur to bucket-items. Prior to the creation of any indexes, the
      <b>Projector and Router</b> takes no action.
     </p>
     
     <p>
      When an index is first created, the Index Service 
      <b>Supervisor</b> contacts the <b>Projector and
      Router</b>; and passes to it the corresponding index-definitions. The <b>Projector and Router</b>
      duly contacts the Data Service, and 
      extracts data from the fields specified by the index-definitions. It then sends the
      data to the <b>Supervisor</b>, so that the index can be populated.
     </p>
     
     <p>
      Subsequently, the <b>Projector and Router</b> continuously examines the stream of mutations provided
      by the Data Service. When this includes a mutation to an indexed field, the mutated data is
      passed by the <b>Projector and Router</b> to the <b>Supervisor</b>, and the index thereby
      updated.
     </p>
     
     <p>
      
     </p>
    </li>
    
    <li>
     <b>Supervisor</b>: The main program of the Index Service; which passes index-definitions 
     to the <b>Projector and Router</b>, creates and stores indexes, and
     handles mutations sent from the <b>Projector and Router</b>.
     
     <p>
      
     </p>
    </li>
    
    <li>
     <b>Query Service</b>: Passes to the <b>Supervisor</b> clients' create-requests and queries, and handles
     the responses.
     <p>
      
     </p>
    </li>
    
    </ul>
   
   <p>
   </p>
   
   
  </section>
  
  <section>
   <title>
    Saving Indexes
   </title>
   
   <p>
    By default, an index is saved on the node on which it is created. Each index is
    created on one bucket only; but multiple indexes may be created on a single
    bucket. 
   </p>
   
   <p>
    The Index Service can be configured to use either <i>standard</i> or <i>memory-optimized</i> 
    storage:
   </p>
   
   <p>
   </p>
   
   <ul>
    <li>
     <i>Standard</i>: The supervisor process persists to disk all changes made to 
     individual indexes. Each index gets a dedicated file. Writes 
     can either be <i>append-only</i>  or <i>write with circular reuse</i>, 
     depending on the write mode selected for global secondary indexes.
     <p>
      
     </p>
    </li>
    
    <li>
     <i>Memory-Optimized</i>: Indexes are saved in-memory. This provides
     increased efficiency for maintenance, scanning, and mutation.
     efficient index maintenance and index scans. 
     A <i>skiplist</i> (rather than a conventional <i>B-tree</i>) structure 
     is used; optimizing memory consumption. Lock-free index-processing
     enhances concurrency. 
     <p>
      
     </p>
    </li>
    
    
   </ul>
   
   
  </section>
  
  <section>
   <title>
    Index Availability
   </title>
   
   <p>
    Indexes are not automatically replicated. To replicate
    a given index manually, a
    differently named index with identical content should be created on a different
    node. This has the following effects:
   </p>
   
   <p>
   </p>
   
   <ul>
    <li>
     If, due to node-failure, the index specified in a query is not available,
     the alternative is automatically used instead.
     
     <p>
      
     </p>
    </li>
    
    <li>
     If all nodes are available, queries use a <i>round-robin</i> algorithm to load-balance 
     scan operations. This ensures that each index on each node takes an equal share of the 
     workload; resulting in higher performance.
     
     <p>
      
     </p>
    </li>
    
    
   </ul>
   
  </section>
  
 </body>
</topic>
